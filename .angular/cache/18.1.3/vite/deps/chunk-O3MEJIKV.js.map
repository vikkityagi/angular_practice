{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store-internals.mjs", "../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store-plugins.mjs", "../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store-operators.mjs", "../../../../../node_modules/@ngxs/store/fesm2022/ngxs-store.mjs"],
  "sourcesContent": ["/**\n * @license Angular v18.1.3\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  constructor(source) {\n    this.source = source;\n    this.destroyed = false;\n    this.destroyRef = inject(DestroyRef);\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n", "import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, untracked } from '@angular/core';\nimport { ReplaySubject, Subject, BehaviorSubject, Observable } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n// This key is used to store metadata on state classes,\n// such as actions and other related information.\nconst ɵMETA_KEY = 'NGXS_META';\n// This key is used to store options on state classes\n// provided through the `@State` decorator.\nconst ɵMETA_OPTIONS_KEY = 'NGXS_OPTIONS_META';\n// This key is used to store selector metadata on selector functions,\n// such as decorated with the `@Selector` or provided through the\n// `createSelector` function.\nconst ɵSELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ɵensureStoreMetadata(target) {\n  if (!target.hasOwnProperty(ɵMETA_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n    Object.defineProperty(target, ɵMETA_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return ɵgetStoreMetadata(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction ɵgetStoreMetadata(target) {\n  return target[ɵMETA_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ɵensureSelectorMetadata(target) {\n  if (!target.hasOwnProperty(ɵSELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    Object.defineProperty(target, ɵSELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return ɵgetSelectorMetadata(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction ɵgetSelectorMetadata(target) {\n  return target[ɵSELECTOR_META_KEY];\n}\nfunction defaultEqualityCheck(a, b) {\n  return a === b;\n}\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  const length = prev.length;\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Memoize a function on its last inputs only.\n * Originally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\nfunction ɵmemoize(func, equalityCheck = defaultEqualityCheck) {\n  let lastArgs = null;\n  let lastResult = null;\n  // we reference arguments instead of spreading them for performance reasons\n  function memoized() {\n    // eslint-disable-next-line prefer-rest-params\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      // eslint-disable-next-line prefer-rest-params, prefer-spread\n      lastResult = func.apply(null, arguments);\n    }\n    // eslint-disable-next-line prefer-rest-params\n    lastArgs = arguments;\n    return lastResult;\n  }\n  memoized.reset = function () {\n    // The hidden (for now) ability to reset the memoization\n    lastArgs = null;\n    lastResult = null;\n  };\n  return memoized;\n}\nclass StateToken {\n  constructor(_name) {\n    this._name = _name;\n    const selectorMetadata = ɵensureSelectorMetadata(this);\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this._name);\n    };\n  }\n  getName() {\n    return this._name;\n  }\n  toString() {\n    return `StateToken[${this._name}]`;\n  }\n}\nconst NG_DEV_MODE$1 = typeof ngDevMode !== 'undefined' && ngDevMode;\nclass ɵInitialState {\n  static {\n    this._value = {};\n  }\n  static set(state) {\n    this._value = state;\n  }\n  static pop() {\n    const state = this._value;\n    this._value = {};\n    return state;\n  }\n}\nconst ɵINITIAL_STATE_TOKEN = new InjectionToken(NG_DEV_MODE$1 ? 'INITIAL_STATE_TOKEN' : '', {\n  providedIn: 'root',\n  factory: () => ɵInitialState.pop()\n});\nclass ɵNgxsAppBootstrappedState extends ReplaySubject {\n  constructor() {\n    super(1);\n  }\n  bootstrap() {\n    this.next(true);\n    this.complete();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function ɵNgxsAppBootstrappedState_Factory(ɵt) {\n      return new (ɵt || ɵNgxsAppBootstrappedState)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ɵNgxsAppBootstrappedState,\n      factory: ɵNgxsAppBootstrappedState.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵNgxsAppBootstrappedState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nconst NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;\n// These tokens are internal and can change at any point.\nconst ɵNGXS_STATE_FACTORY = new InjectionToken(NG_DEV_MODE ? 'ɵNGXS_STATE_FACTORY' : '');\nconst ɵNGXS_STATE_CONTEXT_FACTORY = new InjectionToken(NG_DEV_MODE ? 'ɵNGXS_STATE_CONTEXT_FACTORY' : '');\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n  const callsQueue = [];\n  let busyPushingNext = false;\n  return function callOperation(...args) {\n    if (busyPushingNext) {\n      callsQueue.unshift(args);\n      return;\n    }\n    busyPushingNext = true;\n    operation(...args);\n    while (callsQueue.length > 0) {\n      const nextCallArgs = callsQueue.pop();\n      nextCallArgs && operation(...nextCallArgs);\n    }\n    busyPushingNext = false;\n  };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass ɵOrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n  }\n  next(value) {\n    this._orderedNext(value);\n  }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass ɵOrderedBehaviorSubject extends BehaviorSubject {\n  constructor(value) {\n    super(value);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n    this._currentValue = value;\n  }\n  getValue() {\n    return this._currentValue;\n  }\n  next(value) {\n    this._currentValue = value;\n    this._orderedNext(value);\n  }\n}\nfunction ɵwrapObserverCalls(invokeFn) {\n  return source => {\n    return new Observable(subscriber => {\n      return source.subscribe({\n        next(value) {\n          invokeFn(() => subscriber.next(value));\n        },\n        error(error) {\n          invokeFn(() => subscriber.error(error));\n        },\n        complete() {\n          invokeFn(() => subscriber.complete());\n        }\n      });\n    });\n  };\n}\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass ɵStateStream extends ɵOrderedBehaviorSubject {\n  constructor() {\n    super({});\n    this.state = toSignal(this.pipe(ɵwrapObserverCalls(untracked)), {\n      manualCleanup: true,\n      requireSync: true\n    });\n  }\n  ngOnDestroy() {\n    // The StateStream should never emit values once the root view is removed,\n    // such as when the `NgModuleRef.destroy()` method is called. This is crucial\n    // for preventing memory leaks in server-side rendered apps, where a new StateStream\n    // is created for each HTTP request. If users forget to unsubscribe from `store.select`\n    // or `store.subscribe`, it can result in significant memory leaks in SSR apps.\n    this.complete();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function ɵStateStream_Factory(ɵt) {\n      return new (ɵt || ɵStateStream)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ɵStateStream,\n      factory: ɵStateStream.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵStateStream, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { StateToken, ɵINITIAL_STATE_TOKEN, ɵInitialState, ɵMETA_KEY, ɵMETA_OPTIONS_KEY, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, ɵNgxsAppBootstrappedState, ɵOrderedBehaviorSubject, ɵOrderedSubject, ɵSELECTOR_META_KEY, ɵStateStream, ɵensureSelectorMetadata, ɵensureStoreMetadata, ɵgetSelectorMetadata, ɵgetStoreMetadata, ɵmemoize, ɵwrapObserverCalls };\n", "import { InjectionToken } from '@angular/core';\n\n/**\n * Init action\n */\nclass InitState {\n  static {\n    this.type = '@@INIT';\n  }\n}\n/**\n * Update action\n */\nclass UpdateState {\n  static {\n    this.type = '@@UPDATE_STATE';\n  }\n  constructor(addedStates) {\n    this.addedStates = addedStates;\n  }\n}\nconst NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;\n// The injection token is used to resolve to custom NGXS plugins provided\n// at the root level through either `{provide}` scheme or `withNgxsPlugin`.\nconst NGXS_PLUGINS = new InjectionToken(NG_DEV_MODE ? 'NGXS_PLUGINS' : '');\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n  return action.constructor?.type || action.type;\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n  const type1 = getActionTypeFromInstance(action1);\n  return function (action2) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n  obj = {\n    ...obj\n  };\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : {\n        ...acc[part]\n      };\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue };\n", "/**\n * @param items - Specific items to append to the end of an array\n */\nfunction append(items) {\n  return function appendOperator(existing) {\n    // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n    // just return `existing`\n    const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n    if (itemsNotProvidedButExistingIs) {\n      return existing;\n    }\n    if (Array.isArray(existing)) {\n      return existing.concat(items);\n    }\n    // For example if some property is added dynamically\n    // and didn't exist before thus it's not `ArrayLike`\n    return items;\n  };\n}\nfunction compose(...operators) {\n  return function composeOperator(existing) {\n    return operators.reduce((accumulator, operator) => operator(accumulator), existing);\n  };\n}\nfunction isStateOperator(value) {\n  return typeof value === 'function';\n}\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\nfunction isPredicate(value) {\n  return typeof value === 'function';\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nfunction invalidIndex(index) {\n  return Number.isNaN(index) || index === -1;\n}\nfunction isNil(value) {\n  return value === null || isUndefined(value);\n}\nfunction retrieveValue(operatorOrValue, existing) {\n  // If state operator is a function\n  // then call it with an original value\n  if (isStateOperator(operatorOrValue)) {\n    const value = operatorOrValue(existing);\n    return value;\n  }\n  // If operator or value was not provided\n  // e.g. `elseOperatorOrValue` is `undefined`\n  // then we just return an original value\n  if (isUndefined(operatorOrValue)) {\n    return existing;\n  }\n  return operatorOrValue;\n}\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n  return function iifOperator(existing) {\n    // Convert the value to a boolean\n    let result = !!condition;\n    // but if it is a function then run it to get the result\n    if (isPredicate(condition)) {\n      result = condition(existing);\n    }\n    if (result) {\n      return retrieveValue(trueOperatorOrValue, existing);\n    }\n    return retrieveValue(elseOperatorOrValue, existing);\n  };\n}\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nfunction insertItem(value, beforePosition) {\n  return function insertItemOperator(existing) {\n    // Have to check explicitly for `null` and `undefined`\n    // because `value` can be `0`, thus `!value` will return `true`\n    if (isNil(value) && existing) {\n      return existing;\n    }\n    // Property may be dynamic and might not existed before\n    if (!Array.isArray(existing)) {\n      return [value];\n    }\n    const clone = existing.slice();\n    let index = 0;\n    // No need to call `isNumber`\n    // as we are checking `> 0` not `>= 0`\n    // everything except number will return false here\n    if (beforePosition > 0) {\n      index = beforePosition;\n    }\n    clone.splice(index, 0, value);\n    return clone;\n  };\n}\nfunction patch(patchObject) {\n  return function patchStateOperator(existing) {\n    let clone = null;\n    for (const k in patchObject) {\n      const newValue = patchObject[k];\n      const existingPropValue = existing?.[k];\n      const newPropValue = isStateOperator(newValue) ? newValue(existingPropValue) : newValue;\n      if (newPropValue !== existingPropValue) {\n        if (!clone) {\n          clone = {\n            ...existing\n          };\n        }\n        clone[k] = newPropValue;\n      }\n    }\n    return clone || existing;\n  };\n}\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nfunction updateItem(selector, operatorOrValue) {\n  return function updateItemOperator(existing) {\n    let index = -1;\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n    if (invalidIndex(index)) {\n      return existing;\n    }\n    let value = null;\n    // Need to check if the new item value will change the existing item value\n    // then, only if it will change it then clone the array and set the item\n    const theOperatorOrValue = operatorOrValue;\n    if (isStateOperator(theOperatorOrValue)) {\n      value = theOperatorOrValue(existing[index]);\n    } else {\n      value = theOperatorOrValue;\n    }\n    // If the value hasn't been mutated\n    // then we just return `existing` array\n    if (value === existing[index]) {\n      return existing;\n    }\n    const clone = existing.slice();\n    clone[index] = value;\n    return clone;\n  };\n}\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nfunction removeItem(selector) {\n  return function removeItemOperator(existing) {\n    let index = -1;\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n    if (invalidIndex(index)) {\n      return existing;\n    }\n    const clone = existing.slice();\n    clone.splice(index, 1);\n    return clone;\n  };\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { append, compose, iif, insertItem, isPredicate, isStateOperator, patch, removeItem, updateItem };\n", "import * as i0 from '@angular/core';\nimport { Injectable, NgZone, PLATFORM_ID, Inject, InjectionToken, inject, INJECTOR, Optional, SkipSelf, ErrorHandler, ɵisPromise as _isPromise, computed, makeEnvironmentProviders, ENVIRONMENT_INITIALIZER, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport { Observable, config, Subject, of, forkJoin, throwError, EMPTY, from, isObservable, shareReplay as shareReplay$1, map as map$1, catchError as catchError$1, distinctUntilChanged, take as take$1, ReplaySubject } from 'rxjs';\nimport * as i1 from '@ngxs/store/internals';\nimport { ɵwrapObserverCalls as _wrapObserverCalls, ɵOrderedSubject as _OrderedSubject, ɵmemoize as _memoize, ɵgetStoreMetadata as _getStoreMetadata, ɵgetSelectorMetadata as _getSelectorMetadata, ɵMETA_KEY as _META_KEY, ɵINITIAL_STATE_TOKEN as _INITIAL_STATE_TOKEN, ɵNgxsAppBootstrappedState as _NgxsAppBootstrappedState, ɵNGXS_STATE_CONTEXT_FACTORY as _NGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY as _NGXS_STATE_FACTORY, ɵensureStoreMetadata as _ensureStoreMetadata, ɵMETA_OPTIONS_KEY as _META_OPTIONS_KEY, ɵensureSelectorMetadata as _ensureSelectorMetadata } from '@ngxs/store/internals';\nexport { StateToken } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { share, map, shareReplay, filter, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, tap, startWith, pairwise } from 'rxjs/operators';\nimport { NGXS_PLUGINS, getActionTypeFromInstance, setValue, getValue, InitState, UpdateState } from '@ngxs/store/plugins';\nexport { InitState, NGXS_PLUGINS, UpdateState, actionMatcher, getActionTypeFromInstance, getValue, setValue } from '@ngxs/store/plugins';\nimport { isStateOperator } from '@ngxs/store/operators';\nclass NoopNgxsExecutionStrategy {\n  enter(func) {\n    return func();\n  }\n  leave(func) {\n    return func();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NoopNgxsExecutionStrategy_Factory(ɵt) {\n      return new (ɵt || NoopNgxsExecutionStrategy)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NoopNgxsExecutionStrategy,\n      factory: NoopNgxsExecutionStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NoopNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\nfunction getUndecoratedStateWithInjectableWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction getInvalidInitializationOrderMessage(addedStates) {\n  let message = 'You have an invalid state initialization order. This typically occurs when `NgxsModule.forFeature`\\n' + 'or `provideStates` is called before `NgxsModule.forRoot` or `provideStore`.\\n' + 'One example is when `NgxsRouterPluginModule.forRoot` is called before `NgxsModule.forRoot`.';\n  if (addedStates) {\n    const stateNames = Object.keys(addedStates).map(stateName => `\"${stateName}\"`);\n    message += '\\nFeature states added before the store initialization is complete: ' + `${stateNames.join(', ')}.`;\n  }\n  return message;\n}\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n  constructor(_ngZone, _platformId) {\n    this._ngZone = _ngZone;\n    this._platformId = _platformId;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      verifyZoneIsNotNooped(_ngZone);\n    }\n  }\n  enter(func) {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n    return this.runOutsideAngular(func);\n  }\n  leave(func) {\n    return this.runInsideAngular(func);\n  }\n  runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n    return this._ngZone.run(func);\n  }\n  runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n    return func();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(ɵt) {\n      return new (ɵt || DispatchOutsideZoneNgxsExecutionStrategy)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DispatchOutsideZoneNgxsExecutionStrategy,\n      factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DispatchOutsideZoneNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }], null);\n})();\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n  console.warn(getZoneWarningMessage());\n}\nconst NG_DEV_MODE$8 = typeof ngDevMode !== 'undefined' && ngDevMode;\n/**\n * Consumers have the option to utilize the execution strategy provided by\n * `NgxsModule.forRoot({executionStrategy})` or `provideStore([], {executionStrategy})`.\n */\nconst CUSTOM_NGXS_EXECUTION_STRATEGY = new InjectionToken(NG_DEV_MODE$8 ? 'CUSTOM_NGXS_EXECUTION_STRATEGY' : '');\n/**\n * The injection token is used internally to resolve an instance of the execution\n * strategy. It checks whether consumers have provided their own `executionStrategy`\n * and also verifies if we are operating in a zone-aware environment.\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken(NG_DEV_MODE$8 ? 'NGXS_EXECUTION_STRATEGY' : '', {\n  providedIn: 'root',\n  factory: () => {\n    const ngZone = inject(NgZone);\n    const injector = inject(INJECTOR);\n    const executionStrategy = injector.get(CUSTOM_NGXS_EXECUTION_STRATEGY);\n    const isNgZoneEnabled = ngZone instanceof NgZone;\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(isNgZoneEnabled ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\nclass InternalNgxsExecutionStrategy {\n  constructor(_executionStrategy) {\n    this._executionStrategy = _executionStrategy;\n  }\n  enter(func) {\n    return this._executionStrategy.enter(func);\n  }\n  leave(func) {\n    return this._executionStrategy.leave(func);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function InternalNgxsExecutionStrategy_Factory(ɵt) {\n      return new (ɵt || InternalNgxsExecutionStrategy)(i0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: InternalNgxsExecutionStrategy,\n      factory: InternalNgxsExecutionStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [NGXS_EXECUTION_STRATEGY]\n    }]\n  }], null);\n})();\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return _wrapObserverCalls(fn => ngxsExecutionStrategy.leave(fn));\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends _OrderedSubject {\n  ngOnDestroy() {\n    this.complete();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵInternalActions_BaseFactory;\n      return function InternalActions_Factory(ɵt) {\n        return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = i0.ɵɵgetInheritedFactory(InternalActions)))(ɵt || InternalActions);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: InternalActions,\n      factory: InternalActions.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n  constructor(internalActions$, internalExecutionStrategy) {\n    const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy),\n    // The `InternalActions` subject emits outside of the Angular zone.\n    // We have to re-enter the Angular zone for any incoming consumer.\n    // The `share()` operator reduces the number of change detections.\n    // This would call leave only once for any stream emission across all active subscribers.\n    share());\n    super(observer => {\n      const childSubscription = sharedInternalActions$.subscribe({\n        next: ctx => observer.next(ctx),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      });\n      observer.add(childSubscription);\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function Actions_Factory(ɵt) {\n      return new (ɵt || Actions)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Actions,\n      factory: Actions.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: InternalActions\n  }, {\n    type: InternalNgxsExecutionStrategy\n  }], null);\n})();\nclass PluginManager {\n  constructor(_parentManager, _pluginHandlers) {\n    this._parentManager = _parentManager;\n    this._pluginHandlers = _pluginHandlers;\n    this.plugins = [];\n    this.registerHandlers();\n  }\n  get rootPlugins() {\n    return this._parentManager && this._parentManager.plugins || this.plugins;\n  }\n  registerHandlers() {\n    const pluginHandlers = this.getPluginHandlers();\n    this.rootPlugins.push(...pluginHandlers);\n  }\n  getPluginHandlers() {\n    const handlers = this._pluginHandlers || [];\n    return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function PluginManager_Factory(ɵt) {\n      return new (ɵt || PluginManager)(i0.ɵɵinject(PluginManager, 12), i0.ɵɵinject(NGXS_PLUGINS, 8));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PluginManager,\n      factory: PluginManager.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PluginManager, [{\n    type: Injectable\n  }], () => [{\n    type: PluginManager,\n    decorators: [{\n      type: Optional\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [NGXS_PLUGINS]\n    }, {\n      type: Optional\n    }]\n  }], null);\n})();\nconst ɵɵunhandledRxjsErrorCallbacks = new WeakMap();\nconst existingHandler = config.onUnhandledError;\nconfig.onUnhandledError = function (error) {\n  const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);\n  if (unhandledErrorCallback) {\n    unhandledErrorCallback();\n  } else if (existingHandler) {\n    existingHandler.call(this, error);\n  } else {\n    throw error;\n  }\n};\nfunction executeUnhandledCallback(error) {\n  const unhandledErrorCallback = ɵɵunhandledRxjsErrorCallbacks.get(error);\n  if (unhandledErrorCallback) {\n    unhandledErrorCallback();\n    return true;\n  }\n  return false;\n}\nfunction assignUnhandledCallback(error, callback) {\n  // Since the error can be essentially anything, we must ensure that we only\n  // handle objects, as weak maps do not allow any other key type besides objects.\n  // The error can also be a string if thrown in the following manner: `throwError('My Error')`.\n  if (error !== null && typeof error === 'object') {\n    let hasBeenCalled = false;\n    ɵɵunhandledRxjsErrorCallbacks.set(error, () => {\n      if (!hasBeenCalled) {\n        hasBeenCalled = true;\n        callback();\n      }\n    });\n  }\n  return error;\n}\nfunction fallbackSubscriber(ngZone) {\n  return source => {\n    let subscription = source.subscribe({\n      error: error => {\n        ngZone.runOutsideAngular(() => {\n          // This is necessary to schedule a microtask to ensure that synchronous\n          // errors are not reported before the real subscriber arrives. If an error\n          // is thrown synchronously in any action, it will be reported to the error\n          // handler regardless. Since RxJS reports unhandled errors asynchronously,\n          // implementing a microtask ensures that we are also safe in this scenario.\n          queueMicrotask(() => {\n            if (subscription) {\n              executeUnhandledCallback(error);\n            }\n          });\n        });\n      }\n    });\n    return new Observable(subscriber => {\n      // Now that there is a real subscriber, we can unsubscribe our pro-active subscription\n      subscription?.unsubscribe();\n      subscription = null;\n      return source.subscribe(subscriber);\n    });\n  };\n}\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {\n  /** @nocollapse */static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵInternalDispatchedActionResults_BaseFactory;\n      return function InternalDispatchedActionResults_Factory(ɵt) {\n        return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = i0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(ɵt || InternalDispatchedActionResults);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: InternalDispatchedActionResults,\n      factory: InternalDispatchedActionResults.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatchedActionResults, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nclass InternalDispatcher {\n  constructor(_ngZone, _actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy) {\n    this._ngZone = _ngZone;\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._pluginManager = _pluginManager;\n    this._stateStream = _stateStream;\n    this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n    return result.pipe(fallbackSubscriber(this._ngZone), leaveNgxs(this._ngxsExecutionStrategy));\n  }\n  dispatchByEvents(actionOrActions) {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(undefined);\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action))).pipe(map(() => undefined));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n  dispatchSingle(action) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      const type = getActionTypeFromInstance(action);\n      if (!type) {\n        const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n        return throwError(() => error);\n      }\n    }\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n    return compose([...plugins, (nextState, nextAction) => {\n      if (nextState !== prevState) {\n        this._stateStream.next(nextState);\n      }\n      const actionResult$ = this.getActionResultStream(nextAction);\n      actionResult$.subscribe(ctx => this._actions.next(ctx));\n      this._actions.next({\n        action: nextAction,\n        status: \"DISPATCHED\" /* ActionStatus.Dispatched */\n      });\n      return this.createDispatchObservable(actionResult$);\n    }])(prevState, action).pipe(shareReplay());\n  }\n  getActionResultStream(action) {\n    return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== \"DISPATCHED\" /* ActionStatus.Dispatched */), take(1), shareReplay());\n  }\n  createDispatchObservable(actionResult$) {\n    return actionResult$.pipe(exhaustMap(ctx => {\n      switch (ctx.status) {\n        case \"SUCCESSFUL\" /* ActionStatus.Successful */:\n          // The `createDispatchObservable` function should return the\n          // state, as its result is utilized by plugins.\n          return of(this._stateStream.getValue());\n        case \"ERRORED\" /* ActionStatus.Errored */:\n          return throwError(() => ctx.error);\n        default:\n          return EMPTY;\n      }\n    })).pipe(shareReplay());\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function InternalDispatcher_Factory(ɵt) {\n      return new (ɵt || InternalDispatcher)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(PluginManager), i0.ɵɵinject(i1.ɵStateStream), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: InternalDispatcher,\n      factory: InternalDispatcher.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i0.NgZone\n  }, {\n    type: InternalActions\n  }, {\n    type: InternalDispatchedActionResults\n  }, {\n    type: PluginManager\n  }, {\n    type: i1.ɵStateStream\n  }, {\n    type: InternalNgxsExecutionStrategy\n  }], null);\n})();\nconst NG_DEV_MODE$7 = typeof ngDevMode !== 'undefined' && ngDevMode;\n// The injection token is used to resolve a list of states provided at\n// the root level through either `NgxsModule.forRoot` or `provideStore`.\nconst ROOT_STATE_TOKEN = new InjectionToken(NG_DEV_MODE$7 ? 'ROOT_STATE_TOKEN' : '');\n// The injection token is used to resolve a list of states provided at\n// the feature level through either `NgxsModule.forFeature` or `provideStates`.\n// The Array<Array> is used to overload the resolved value of the token because\n// it is a multi-provider token.\nconst FEATURE_STATE_TOKEN = new InjectionToken(NG_DEV_MODE$7 ? 'FEATURE_STATE_TOKEN' : '');\n// The injection token is used to resolve to options provided at the root\n// level through either `NgxsModule.forRoot` or `provideStore`.\nconst NGXS_OPTIONS = new InjectionToken(NG_DEV_MODE$7 ? 'NGXS_OPTIONS' : '');\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n  constructor() {\n    this.compatibility = {\n      strictContentSecurityPolicy: false\n    };\n    /**\n     * Determines the execution context to perform async operations inside. An implementation can be\n     * provided to override the default behaviour where the async operations are run\n     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.\n     * These observable behaviours are from:\n     *   `store.selectSignal(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`\n     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your\n     * application doesn't rely on zone.js running change detection then you can switch to the\n     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.\n     * (default: null)\n     */\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n    /**\n     * Defining shared selector options\n     */\n    this.selectorOptions = {\n      injectContainerState: false,\n      suppressErrors: false\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsConfig_Factory(ɵt) {\n      return new (ɵt || NgxsConfig)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgxsConfig,\n      factory: () => (() => {\n        const defaultConfig = new NgxsConfig();\n        const config = inject(NGXS_OPTIONS);\n        return {\n          ...defaultConfig,\n          ...config,\n          selectorOptions: {\n            ...defaultConfig.selectorOptions,\n            ...config.selectorOptions\n          }\n        };\n      })(),\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: () => {\n        const defaultConfig = new NgxsConfig();\n        const config = inject(NGXS_OPTIONS);\n        return {\n          ...defaultConfig,\n          ...config,\n          selectorOptions: {\n            ...defaultConfig.selectorOptions,\n            ...config.selectorOptions\n          }\n        };\n      }\n    }]\n  }], null, null);\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n}\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n\n/**\n * @ignore\n */\nclass InternalStateOperations {\n  constructor(_stateStream, _dispatcher, _config) {\n    this._stateStream = _stateStream;\n    this._dispatcher = _dispatcher;\n    this._config = _config;\n  }\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations() {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n    };\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n    } else {\n      return rootStateOperations;\n    }\n  }\n  setStateToTheCurrentWithNew(results) {\n    const stateOperations = this.getRootStateOperations();\n    // Get our current stream\n    const currentState = stateOperations.getState();\n    // Set the state to the current + new\n    stateOperations.setState({\n      ...currentState,\n      ...results.defaults\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function InternalStateOperations_Factory(ɵt) {\n      return new (ɵt || InternalStateOperations)(i0.ɵɵinject(i1.ɵStateStream), i0.ɵɵinject(InternalDispatcher), i0.ɵɵinject(NgxsConfig));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: InternalStateOperations,\n      factory: InternalStateOperations.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalStateOperations, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i1.ɵStateStream\n  }, {\n    type: InternalDispatcher\n  }, {\n    type: NgxsConfig\n  }], null);\n})();\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\nconst NG_DEV_MODE$6 = typeof ngDevMode !== 'undefined' && ngDevMode;\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n  return context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    const {\n      suppressErrors\n    } = selectorOptions;\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n      // If the lambda attempts to access something in the state that doesn't exist,\n      // it will throw a `TypeError`. Since this behavior is common, we simply return\n      // `undefined` in such cases.\n      try {\n        return memoizedSelectorFn(...results);\n      } catch (ex) {\n        if (suppressErrors && ex instanceof TypeError) {\n          return undefined;\n        }\n        // We're logging an error in this function because it may be used by `select`,\n        // `selectSignal`, and `selectSnapshot`. Therefore, there's no need to catch\n        // exceptions there to log errors.\n        if (NG_DEV_MODE$6) {\n          const message = 'The selector below has thrown an error upon invocation. ' + 'Please check for any unsafe property access that may result in null ' + 'or undefined values.';\n          // Avoid concatenating the message with the original function, as this will\n          // invoke `toString()` on the function. Instead, log it as the second argument.\n          // This way, developers will be able to navigate to the actual code in the browser.\n          console.error(message, selectorMetaData.originalFn);\n        }\n        throw ex;\n      }\n    };\n  };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn.apply(containerClass, args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = _memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = _memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  // The container state refers to the state class that includes the\n  // definition of the selector function, for example:\n  // @State()\n  // class AnimalsState {\n  //   @Selector()\n  //   static getAnimals(state: AnimalsStateModel) {}\n  // }\n  // The `AnimalsState` serves as the container state. Additionally, the\n  // selector may reside within a namespace or another class lacking the\n  // `@State` decorator, thus not being treated as the container state.\n  const canInjectContainerState = selectorOptions.injectContainerState || selectors.length === 0;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = _getStoreMetadata(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  selectorsToApply.push(...selectors);\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n  const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);\n  return metadata && metadata.makeRootSelector || (() => selector);\n}\nconst NG_DEV_MODE$5 = typeof ngDevMode !== 'undefined' && ngDevMode;\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n  return obj => {\n    for (let i = 0; i < paths.length; i++) {\n      if (!obj) return undefined;\n      obj = obj[paths[i]];\n    }\n    return obj;\n  };\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n *\n * Marked for removal. It's only used within `createSelectorFn`.\n */\nfunction propGetter(paths, config) {\n  if (config?.compatibility?.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n// This injection token selects the prop getter implementation once the app is\n// bootstrapped, as the `propGetter` function's behavior determines the implementation\n// each time it's called. It accepts the config as the second argument. We no longer\n// need to check for the `strictContentSecurityPolicy` every time the prop getter\n// implementation is selected. Now, the `propGetter` function is only used within\n// `createSelectorFn`, which, in turn, is solely used by the `Select` decorator.\n// We've been trying to deprecate the `Select` decorator because it's unstable with\n// server-side rendering and micro-frontend applications.\nconst ɵPROP_GETTER = new InjectionToken(NG_DEV_MODE$5 ? 'PROP_GETTER' : '', {\n  providedIn: 'root',\n  factory: () => inject(NgxsConfig).compatibility?.strictContentSecurityPolicy ? compliantPropGetter : fastPropGetter\n});\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n  const findName = stateClass => {\n    const meta = stateClasses.find(g => g === stateClass);\n    if (NG_DEV_MODE$5 && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n    return meta[_META_KEY].name;\n  };\n  return stateClasses.reduce((result, stateClass) => {\n    const {\n      name,\n      children\n    } = stateClass[_META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[_META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n  const visit = (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n  const visit = (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(dep => {\n      if (NG_DEV_MODE$5 && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n      if (visited[dep]) {\n        return;\n      }\n      visit(dep, ancestors.slice(0));\n    });\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n  Object.keys(graph).forEach(k => visit(k));\n  return sorted.reverse();\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* ActionStatus.Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* ActionStatus.Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\" /* ActionStatus.Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [\"SUCCESSFUL\" /* ActionStatus.Successful */, \"CANCELED\" /* ActionStatus.Canceled */, \"ERRORED\" /* ActionStatus.Errored */];\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\" /* ActionStatus.Errored */], mapActionResult);\n}\nfunction ofActionOperator(allowedTypes, statuses,\n// This could have been written as\n// `OperatorFunction<ActionContext, ActionCompletion | any>`, as it maps\n// either to `ctx.action` or to `ActionCompletion`. However,\n// `ActionCompletion | any` defaults to `any`, rendering the union\n// type meaningless.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: \"SUCCESSFUL\" /* ActionStatus.Successful */ === status,\n        canceled: \"CANCELED\" /* ActionStatus.Canceled */ === status,\n        error\n      }\n    };\n  });\n}\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n    const newState = {\n      ...existingState\n    };\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n    return newState;\n  };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n  constructor(_internalStateOperations) {\n    this._internalStateOperations = _internalStateOperations;\n  }\n  /**\n   * Create the state context\n   */\n  createStateContext(mappedStore) {\n    const root = this._internalStateOperations.getRootStateOperations();\n    return {\n      getState() {\n        const currentAppState = root.getState();\n        return getState(currentAppState, mappedStore.path);\n      },\n      patchState(val) {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch(val);\n        setStateFromOperator(root, currentAppState, patchOperator, mappedStore.path);\n      },\n      setState(val) {\n        const currentAppState = root.getState();\n        if (isStateOperator(val)) {\n          setStateFromOperator(root, currentAppState, val, mappedStore.path);\n        } else {\n          setStateValue(root, currentAppState, val, mappedStore.path);\n        }\n      },\n      dispatch(actions) {\n        return root.dispatch(actions);\n      }\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function StateContextFactory_Factory(ɵt) {\n      return new (ɵt || StateContextFactory)(i0.ɵɵinject(InternalStateOperations));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: StateContextFactory,\n      factory: StateContextFactory.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateContextFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: InternalStateOperations\n  }], null);\n})();\nfunction setStateValue(root, currentAppState, newValue, path) {\n  const newAppState = setValue(currentAppState, path, newValue);\n  root.setState(newAppState);\n  return newAppState;\n  // In doing this refactoring I noticed that there is a 'bug' where the\n  // application state is returned instead of this state slice.\n  // This has worked this way since the beginning see:\n  // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n  // This needs to be fixed, but is a 'breaking' change.\n  // I will do this fix in a subsequent PR and we can decide how to handle it.\n}\nfunction setStateFromOperator(root, currentAppState, stateOperator, path) {\n  const local = getState(currentAppState, path);\n  const newValue = stateOperator(local);\n  return setStateValue(root, currentAppState, newValue, path);\n}\nfunction getState(currentAppState, path) {\n  return getValue(currentAppState, path);\n}\nconst stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\nfunction ensureStateNameIsValid(name) {\n  if (!name) {\n    throwStateNamePropertyError();\n  } else if (!stateNameRegex.test(name)) {\n    throwStateNameError(name);\n  }\n}\nfunction ensureStateNameIsUnique(stateName, state, statesByName) {\n  const existingState = statesByName[stateName];\n  if (existingState && existingState !== state) {\n    throwStateUniqueError(stateName, state.name, existingState.name);\n  }\n}\nfunction ensureStatesAreDecorated(stateClasses) {\n  stateClasses.forEach(stateClass => {\n    if (!_getStoreMetadata(stateClass)) {\n      throwStateDecoratorError(stateClass.name);\n    }\n  });\n}\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n  if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n    return;\n  }\n  console.warn(getUndecoratedStateWithInjectableWarningMessage(stateClass.name));\n}\nfunction aot_hasNgInjectableDef(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  return !!stateClass.ɵprov;\n}\nfunction jit_hasInjectableAnnotation(stateClass) {\n  // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n  const annotations = stateClass.__annotations__ || [];\n  return annotations.some(annotation => annotation?.ngMetadataName === 'Injectable');\n}\nconst NG_DEV_MODE$4 = typeof ngDevMode !== 'undefined' && ngDevMode;\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken(NG_DEV_MODE$4 ? 'NGXS_DEVELOPMENT_OPTIONS' : '', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\nclass NgxsUnhandledActionsLogger {\n  constructor(options) {\n    /**\n     * These actions should be ignored by default; the user can increase this\n     * list in the future via the `ignoreActions` method.\n     */\n    this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n    if (typeof options.warnOnUnhandledActions === 'object') {\n      this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n    }\n  }\n  /**\n   * Adds actions to the internal list of actions that should be ignored.\n   */\n  ignoreActions(...actions) {\n    for (const action of actions) {\n      this._ignoredActions.add(action.type);\n    }\n  }\n  /** @internal */\n  warn(action) {\n    const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n    if (actionShouldBeIgnored) {\n      return;\n    }\n    action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n    console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsUnhandledActionsLogger_Factory(ɵt) {\n      return new (ɵt || NgxsUnhandledActionsLogger)(i0.ɵɵinject(NGXS_DEVELOPMENT_OPTIONS));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgxsUnhandledActionsLogger,\n      factory: NgxsUnhandledActionsLogger.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledActionsLogger, [{\n    type: Injectable\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [NGXS_DEVELOPMENT_OPTIONS]\n    }]\n  }], null);\n})();\nclass NgxsUnhandledErrorHandler {\n  constructor() {\n    this._ngZone = inject(NgZone);\n    this._errorHandler = inject(ErrorHandler);\n  }\n  /**\n   * The `_unhandledErrorContext` is left unused internally since we do not\n   * require it for internal operations. However, developers who wish to provide\n   * their own custom error handler may utilize this context information.\n   */\n  handleError(error, _unhandledErrorContext) {\n    // In order to avoid duplicate error handling, it is necessary to leave\n    // the Angular zone to ensure that errors are not caught twice. The `handleError`\n    // method may contain a `throw error` statement, which is used to re-throw the error.\n    // If the error is re-thrown within the Angular zone, it will be caught again by the\n    // Angular zone. By default, `@angular/core` leaves the Angular zone when invoking\n    // `handleError` (see `_callAndReportToErrorHandler`).\n    this._ngZone.runOutsideAngular(() => this._errorHandler.handleError(error));\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsUnhandledErrorHandler_Factory(ɵt) {\n      return new (ɵt || NgxsUnhandledErrorHandler)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgxsUnhandledErrorHandler,\n      factory: NgxsUnhandledErrorHandler.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledErrorHandler, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nconst NG_DEV_MODE$3 = typeof ngDevMode !== 'undefined' && ngDevMode;\nfunction cloneDefaults(defaults) {\n  let value = defaults === undefined ? {} : defaults;\n  if (defaults) {\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (typeof defaults === 'object') {\n      value = {\n        ...defaults\n      };\n    }\n  }\n  return value;\n}\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n * See its constructor, state factories inject state factories that are\n * parent-level providers. This is required to get feature states from the\n * injector on the same level.\n *\n * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.\n * The `StateFactory` is initialized on the feature level and goes through `...states`\n * to get them from the injector through `injector.get(state)`.\n * @ignore\n */\nclass StateFactory {\n  constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n    this._injector = _injector;\n    this._config = _config;\n    this._parentFactory = _parentFactory;\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._stateContextFactory = _stateContextFactory;\n    this._initialState = _initialState;\n    this._actionsSubscription = null;\n    this._propGetter = inject(ɵPROP_GETTER);\n    this._ngxsUnhandledErrorHandler = null;\n    this._states = [];\n    this._statesByName = {};\n    this._statePaths = {};\n    this.getRuntimeSelectorContext = _memoize(() => {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const stateFactory = this;\n      const propGetter = stateFactory._propGetter;\n      function resolveGetter(key) {\n        const path = stateFactory.statePaths[key];\n        return path ? propGetter(path.split('.')) : null;\n      }\n      const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n        getStateGetter(key) {\n          // Use `@__INLINE__` annotation to forcely inline `resolveGetter`.\n          // This is a Terser annotation, which will function only in the production mode.\n          let getter = /*@__INLINE__*/resolveGetter(key);\n          if (getter) {\n            return getter;\n          }\n          return (...args) => {\n            // Late loaded getter\n            if (!getter) {\n              getter = /*@__INLINE__*/resolveGetter(key);\n            }\n            return getter ? getter(...args) : undefined;\n          };\n        },\n        getSelectorOptions(localOptions) {\n          const globalSelectorOptions = stateFactory._config.selectorOptions;\n          return {\n            ...globalSelectorOptions,\n            ...(localOptions || {})\n          };\n        }\n      };\n      return context;\n    });\n  }\n  get states() {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n  get statesByName() {\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n  }\n  get statePaths() {\n    return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n  }\n  ngOnDestroy() {\n    this._actionsSubscription?.unsubscribe();\n  }\n  /**\n   * Add a new state to the global defs.\n   */\n  add(stateClasses) {\n    if (NG_DEV_MODE$3) {\n      ensureStatesAreDecorated(stateClasses);\n    }\n    const {\n      newStates\n    } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n    const stateGraph = buildGraph(newStates);\n    const sortedStates = topologicalSort(stateGraph);\n    const paths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(newStates);\n    const bootstrappedStores = [];\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n      const path = paths[name];\n      const meta = stateClass[_META_KEY];\n      this.addRuntimeInfoToMeta(meta, path);\n      // Note: previously we called `ensureStateClassIsInjectable` within the\n      // `State` decorator. This check is moved here because the `ɵprov` property\n      // will not exist on the class in JIT mode (because it's set asynchronously\n      // during JIT compilation through `Object.defineProperty`).\n      if (NG_DEV_MODE$3) {\n        ensureStateClassIsInjectable(stateClass);\n      }\n      const stateMap = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: this._injector.get(stateClass),\n        defaults: cloneDefaults(meta.defaults)\n      };\n      // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n      this.states.push(stateMap);\n    }\n    return bootstrappedStores;\n  }\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n  addAndReturnDefaults(stateClasses) {\n    const classes = stateClasses || [];\n    const mappedStores = this.add(classes);\n    const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n    return {\n      defaults,\n      states: mappedStores\n    };\n  }\n  connectActionHandlers() {\n    // Note: We have to connect actions only once when the `StateFactory`\n    //       is being created for the first time. This checks if we're in\n    //       a child state factory and the parent state factory already exists.\n    if (this._parentFactory || this._actionsSubscription !== null) {\n      return;\n    }\n    const dispatched$ = new Subject();\n    this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === \"DISPATCHED\" /* ActionStatus.Dispatched */), mergeMap(ctx => {\n      dispatched$.next(ctx);\n      const action = ctx.action;\n      return this.invokeActions(dispatched$, action).pipe(map(() => ({\n        action,\n        status: \"SUCCESSFUL\" /* ActionStatus.Successful */\n      })), defaultIfEmpty({\n        action,\n        status: \"CANCELED\" /* ActionStatus.Canceled */\n      }), catchError(error => {\n        const ngxsUnhandledErrorHandler = this._ngxsUnhandledErrorHandler ||= this._injector.get(NgxsUnhandledErrorHandler);\n        const handleableError = assignUnhandledCallback(error, () => ngxsUnhandledErrorHandler.handleError(error, {\n          action\n        }));\n        return of({\n          action,\n          status: \"ERRORED\" /* ActionStatus.Errored */,\n          error: handleableError\n        });\n      }));\n    })).subscribe(ctx => this._actionResults.next(ctx));\n  }\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(dispatched$, action) {\n    const type = getActionTypeFromInstance(action);\n    const results = [];\n    // Determines whether the dispatched action has been handled, this is assigned\n    // to `true` within the below `for` loop if any `actionMetas` has been found.\n    let actionHasBeenHandled = false;\n    for (const metadata of this.states) {\n      const actionMetas = metadata.actions[type];\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n            // We need to use `isPromise` instead of checking whether\n            // `result instanceof Promise`. In zone.js patched environments, `global.Promise`\n            // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js\n            // for certain reasons, might not work with `instanceof`. For instance, the dynamic\n            // import returns a native promise (not a `ZoneAwarePromise`), causing this check to\n            // be falsy.\n            if (_isPromise(result)) {\n              result = from(result);\n            }\n            if (isObservable(result)) {\n              // If this observable has been completed w/o emitting\n              // any value then we wouldn't want to complete the whole chain\n              // of actions. Since if any observable completes then\n              // action will be canceled.\n              // For instance if any action handler would've had such statement:\n              // `handler(ctx) { return EMPTY; }`\n              // then the action will be canceled.\n              // See https://github.com/ngxs/store/issues/1568\n              result = result.pipe(mergeMap(value => {\n                if (_isPromise(value)) {\n                  return from(value);\n                }\n                if (isObservable(value)) {\n                  return value;\n                }\n                return of(value);\n              }), defaultIfEmpty({}));\n              if (actionMeta.options.cancelUncompleted) {\n                // todo: ofActionDispatched should be used with action class\n                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n              }\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n          actionHasBeenHandled = true;\n        }\n      }\n    }\n    // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n    // only during development.\n    if (NG_DEV_MODE$3 && !actionHasBeenHandled) {\n      const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n      // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n      // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n      // didn't return `null` so we may ensure the module has been imported.\n      if (unhandledActionsLogger) {\n        unhandledActionsLogger.warn(action);\n      }\n    }\n    if (!results.length) {\n      results.push(of({}));\n    }\n    return forkJoin(results);\n  }\n  addToStatesMap(stateClasses) {\n    const newStates = [];\n    const statesMap = this.statesByName;\n    for (const stateClass of stateClasses) {\n      const stateName = _getStoreMetadata(stateClass).name;\n      if (NG_DEV_MODE$3) {\n        ensureStateNameIsUnique(stateName, stateClass, statesMap);\n      }\n      const unmountedState = !statesMap[stateName];\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n    return {\n      newStates\n    };\n  }\n  addRuntimeInfoToMeta(meta, path) {\n    this.statePaths[meta.name] = path;\n    // TODO: versions after v3 - we plan to get rid of the `path` property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative to what was exposed in v3 because this is used by many plugins\n    meta.path = path;\n  }\n  hasBeenMountedAndBootstrapped(name, path) {\n    const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n    // This checks whether a state has been already added to the global graph and\n    // its lifecycle is in 'bootstrapped' state.\n    return this.statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function StateFactory_Factory(ɵt) {\n      return new (ɵt || StateFactory)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(StateFactory, 12), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(_INITIAL_STATE_TOKEN, 8));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: StateFactory,\n      factory: StateFactory.ɵfac\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateFactory, [{\n    type: Injectable\n  }], () => [{\n    type: i0.Injector\n  }, {\n    type: NgxsConfig\n  }, {\n    type: StateFactory,\n    decorators: [{\n      type: Optional\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: InternalActions\n  }, {\n    type: InternalDispatchedActionResults\n  }, {\n    type: StateContextFactory\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_INITIAL_STATE_TOKEN]\n    }]\n  }], null);\n})();\nclass Store {\n  constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n    this._stateStream = _stateStream;\n    this._internalStateOperations = _internalStateOperations;\n    this._config = _config;\n    this._internalExecutionStrategy = _internalExecutionStrategy;\n    this._stateFactory = _stateFactory;\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n    this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay$1({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.initStateStream(initialStateValue);\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n  }\n  /**\n   * Selects a slice of data from the store.\n   */\n  select(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._selectableStateStream.pipe(map$1(selectorFn), catchError$1(error => {\n      // if error is TypeError we swallow it to prevent usual errors with property access\n      if (this._config.selectorOptions.suppressErrors && error instanceof TypeError) {\n        return of(undefined);\n      }\n      // rethrow other errors\n      return throwError(error);\n    }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n  }\n  /**\n   * Select one slice of data from the store.\n   */\n  selectOnce(selector) {\n    return this.select(selector).pipe(take$1(1));\n  }\n  /**\n   * Select a snapshot from the state.\n   */\n  selectSnapshot(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n  /**\n   * Select a signal from the state.\n   */\n  selectSignal(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return computed(() => selectorFn(this._stateStream.state()));\n  }\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn) {\n    return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot() {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state) {\n    this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n  getStoreBoundSelectorFn(selector) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n    return makeSelectorFn(runtimeContext);\n  }\n  initStateStream(initialStateValue) {\n    const value = this._stateStream.value;\n    const storeIsEmpty = !value || Object.keys(value).length === 0;\n    if (storeIsEmpty) {\n      this._stateStream.next(initialStateValue);\n    }\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function Store_Factory(ɵt) {\n      return new (ɵt || Store)(i0.ɵɵinject(i1.ɵStateStream), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(StateFactory), i0.ɵɵinject(_INITIAL_STATE_TOKEN, 8));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Store,\n      factory: Store.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Store, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i1.ɵStateStream\n  }, {\n    type: InternalStateOperations\n  }, {\n    type: NgxsConfig\n  }, {\n    type: InternalNgxsExecutionStrategy\n  }, {\n    type: StateFactory\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_INITIAL_STATE_TOKEN]\n    }]\n  }], null);\n})();\nconst NG_DEV_MODE$2 = typeof ngDevMode !== 'undefined' && ngDevMode;\n/**\n * InjectionToken that registers preboot functions (called before the root initializer).\n */\nconst NGXS_PREBOOT_FNS = new InjectionToken(NG_DEV_MODE$2 ? 'NGXS_PREBOOT_FNS' : '');\n/**\n * This function registers a preboot function which will be called before the root\n * store initializer is run, but after all of the NGXS features are provided and\n * available for injection. This is useful for registering action stream listeners\n * before any action is dispatched.\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore(\n *       [CountriesState],\n *       withNgxsPreboot(() => {\n *         const actions$ = inject(Actions);\n *         actions$.subscribe(ctx => console.log(ctx));\n *       })\n *     )\n *   ]\n * });\n * ```\n */\nfunction withNgxsPreboot(prebootFn) {\n  return makeEnvironmentProviders([{\n    provide: NGXS_PREBOOT_FNS,\n    multi: true,\n    useValue: prebootFn\n  }]);\n}\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n  static {\n    this.store = null;\n  }\n  static {\n    this.config = null;\n  }\n  constructor(store, config) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n  }\n  ngOnDestroy() {\n    SelectFactory.store = null;\n    SelectFactory.config = null;\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function SelectFactory_Factory(ɵt) {\n      return new (ɵt || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: SelectFactory,\n      factory: SelectFactory.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SelectFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: Store\n  }, {\n    type: NgxsConfig\n  }], null);\n})();\nconst NG_DEV_MODE$1 = typeof ngDevMode !== 'undefined' && ngDevMode;\nclass LifecycleStateManager {\n  constructor(_store, _internalStateOperations, _stateContextFactory, _appBootstrappedState) {\n    this._store = _store;\n    this._internalStateOperations = _internalStateOperations;\n    this._stateContextFactory = _stateContextFactory;\n    this._appBootstrappedState = _appBootstrappedState;\n    this._destroy$ = new ReplaySubject(1);\n  }\n  ngOnDestroy() {\n    this._destroy$.next();\n  }\n  ngxsBootstrap(action, results) {\n    if (NG_DEV_MODE$1) {\n      if (action instanceof InitState) {\n        this._initStateHasBeenDispatched = true;\n      } else if (\n      // This is a dev mode-only check that ensures the correct order of\n      // state initialization. The `NgxsModule.forRoot` or `provideStore` should\n      // always come first, followed by `forFeature` and `provideStates`. If the\n      // `UpdateState` is dispatched before the `InitState` is dispatched, it indicates\n      // that modules or providers are in an invalid order.\n      action instanceof UpdateState && !this._initStateHasBeenDispatched) {\n        console.error(getInvalidInitializationOrderMessage(action.addedStates));\n      }\n    }\n    this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._appBootstrappedState), filter(appBootstrapped => !!appBootstrapped), takeUntil(this._destroy$)).subscribe(() => this._invokeBootstrapOnStates(results.states));\n  }\n  _invokeInitOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsOnChanges) {\n        this._store.select(state => getValue(state, mappedStore.path)).pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$)).subscribe(([previousValue, currentValue]) => {\n          const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n          instance.ngxsOnChanges(change);\n        });\n      }\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this._getStateContext(mappedStore));\n      }\n      mappedStore.isInitialised = true;\n    }\n  }\n  _invokeBootstrapOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n      }\n    }\n  }\n  _getStateContext(mappedStore) {\n    return this._stateContextFactory.createStateContext(mappedStore);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function LifecycleStateManager_Factory(ɵt) {\n      return new (ɵt || LifecycleStateManager)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(i1.ɵNgxsAppBootstrappedState));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LifecycleStateManager,\n      factory: LifecycleStateManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LifecycleStateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: Store\n  }, {\n    type: InternalStateOperations\n  }, {\n    type: StateContextFactory\n  }, {\n    type: i1.ɵNgxsAppBootstrappedState\n  }], null);\n})();\nconst NG_DEV_MODE = typeof ngDevMode !== 'undefined' && ngDevMode;\n/**\n * This function is shared by both NgModule and standalone features.\n * When using `NgxsModule.forRoot` and `provideStore`, we can depend on the\n * same initialization functionality.\n */\nfunction rootStoreInitializer() {\n  const prebootFns = inject(NGXS_PREBOOT_FNS, {\n    optional: true\n  }) || [];\n  prebootFns.forEach(prebootFn => prebootFn());\n  const factory = inject(StateFactory);\n  const internalStateOperations = inject(InternalStateOperations);\n  inject(Store);\n  inject(SelectFactory);\n  const states = inject(ROOT_STATE_TOKEN, {\n    optional: true\n  }) || [];\n  const lifecycleStateManager = inject(LifecycleStateManager);\n  // Add stores to the state graph and return their defaults.\n  const results = factory.addAndReturnDefaults(states);\n  internalStateOperations.setStateToTheCurrentWithNew(results);\n  // Connect our actions stream.\n  factory.connectActionHandlers();\n  // Dispatch the init action and invoke init and bootstrap functions after.\n  lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n}\n/**\n * This function is utilized by both NgModule and standalone features.\n * When using `NgxsModule.forFeature` and `provideStates`, we can depend on\n * the same initialization functionality.\n */\nfunction featureStatesInitializer() {\n  inject(Store);\n  const internalStateOperations = inject(InternalStateOperations);\n  const factory = inject(StateFactory);\n  const states = inject(FEATURE_STATE_TOKEN, {\n    optional: true\n  }) || [];\n  const lifecycleStateManager = inject(LifecycleStateManager);\n  // Since FEATURE_STATE_TOKEN is a multi token, we need to\n  // flatten it [[Feature1State, Feature2State], [Feature3State]].\n  const flattenedStates = states.reduce((total, values) => total.concat(values), []);\n  // add stores to the state graph and return their defaults.\n  const results = factory.addAndReturnDefaults(flattenedStates);\n  if (results.states.length) {\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n    // Dispatch the update action and invoke init and bootstrap functions after.\n    lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n  }\n}\n/**\n * InjectionToken that registers the global Store.\n */\nconst NGXS_ROOT_STORE_INITIALIZER = new InjectionToken(NG_DEV_MODE ? 'NGXS_ROOT_STORE_INITIALIZER' : '');\n/**\n * InjectionToken that registers feature states.\n */\nconst NGXS_FEATURE_STORE_INITIALIZER = new InjectionToken(NG_DEV_MODE ? 'NGXS_FEATURE_STORE_INITIALIZER' : '');\nconst NGXS_ROOT_ENVIRONMENT_INITIALIZER = [{\n  provide: NGXS_ROOT_STORE_INITIALIZER,\n  useFactory: rootStoreInitializer\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(NGXS_ROOT_STORE_INITIALIZER);\n  }\n}];\n/**\n * The `NGXS_FEATURE_ENVIRONMENT_INITIALIZER` functions as an environment initializer\n * at the `Route` level. Angular Router creates an environment route injector for each\n * matched route where navigation occurs. The injector is created once, ensuring that\n * the feature states initialization only happens once as well.\n */\nconst NGXS_FEATURE_ENVIRONMENT_INITIALIZER = [{\n  provide: NGXS_FEATURE_STORE_INITIALIZER,\n  useFactory: featureStatesInitializer\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(NGXS_FEATURE_STORE_INITIALIZER);\n  }\n}];\n\n/**\n * @ignore\n */\nclass NgxsRootModule {\n  constructor() {\n    rootStoreInitializer();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsRootModule_Factory(ɵt) {\n      return new (ɵt || NgxsRootModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxsRootModule\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRootModule, [{\n    type: NgModule\n  }], () => [], null);\n})();\n\n/**\n * @ignore\n */\nclass NgxsFeatureModule {\n  constructor() {\n    featureStatesInitializer();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsFeatureModule_Factory(ɵt) {\n      return new (ɵt || NgxsFeatureModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxsFeatureModule\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFeatureModule, [{\n    type: NgModule\n  }], () => [], null);\n})();\n\n/**\n * This function provides the required providers when invoking `NgxsModule.forRoot`\n * or `provideStore`. It is shared between the NgModule and standalone APIs.\n */\nfunction getRootProviders(states, options) {\n  return [StateFactory, PluginManager, ...states, {\n    provide: ROOT_STATE_TOKEN,\n    useValue: states\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    useFactory: () => {\n      const appBootstrappedState = inject(_NgxsAppBootstrappedState);\n      return () => appBootstrappedState.bootstrap();\n    },\n    multi: true\n  }, {\n    provide: NGXS_OPTIONS,\n    useValue: options\n  }, {\n    provide: CUSTOM_NGXS_EXECUTION_STRATEGY,\n    useValue: options.executionStrategy\n  }, {\n    provide: _NGXS_STATE_CONTEXT_FACTORY,\n    useExisting: StateContextFactory\n  }, {\n    provide: _NGXS_STATE_FACTORY,\n    useExisting: StateFactory\n  }];\n}\n\n/**\n * This function provides the required providers when calling `NgxsModule.forFeature`\n * or `provideStates`. It is shared between the NgModule and standalone APIs.\n */\nfunction getFeatureProviders(states) {\n  return [StateFactory, PluginManager, ...states, {\n    provide: FEATURE_STATE_TOKEN,\n    multi: true,\n    useValue: states\n  }];\n}\nclass NgxsModule {\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: getRootProviders(states, options)\n    };\n  }\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: getFeatureProviders(states)\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsModule_Factory(ɵt) {\n      return new (ɵt || NgxsModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxsModule\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * Decorates a method with action information.\n */\nfunction Action(actions, options) {\n  return (target, name,\n  // This parameter ensures that the decorated method has a call signature that could be passed an instance of the given action(s).\n  _descriptor) => {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      const isStaticMethod = target.hasOwnProperty('prototype');\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n    const meta = _ensureStoreMetadata(target.constructor);\n    const actionArray = Array.isArray(actions) ? actions : [actions];\n    for (const action of actionArray) {\n      const type = action.type;\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n  return target => {\n    const stateClass = target;\n    const meta = _ensureStoreMetadata(stateClass);\n    const inheritedStateClass = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance = getStateOptions(inheritedStateClass, options);\n    mutateMetaData({\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    });\n    stateClass[_META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\nfunction getStateOptions(inheritedStateClass, options) {\n  const inheritanceOptions = inheritedStateClass[_META_OPTIONS_KEY] || {};\n  return {\n    ...inheritanceOptions,\n    ...options\n  };\n}\nfunction mutateMetaData(params) {\n  const {\n    meta,\n    inheritedStateClass,\n    optionsWithInheritance\n  } = params;\n  const {\n    children,\n    defaults,\n    name\n  } = optionsWithInheritance;\n  const stateName = typeof name === 'string' ? name : name && name.getName() || null;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureStateNameIsValid(stateName);\n  }\n  if (inheritedStateClass.hasOwnProperty(_META_KEY)) {\n    const inheritedMeta = inheritedStateClass[_META_KEY] || {};\n    meta.actions = {\n      ...meta.actions,\n      ...inheritedMeta.actions\n    };\n  }\n  meta.children = children;\n  meta.defaults = defaults;\n  meta.name = stateName;\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n  return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n *\n * @deprecated\n * Read the deprecation notice at this link: https://ngxs.io/deprecations/select-decorator-deprecation.\n */\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target && target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = _ensureSelectorMetadata(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName || null;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = {\n    ...selectorMetaData\n  };\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return {\n    ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}),\n    ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}),\n    ...(selectorMetaData.getSelectorOptions() || {}),\n    ...explicitOptions\n  };\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor ||= Object.getOwnPropertyDescriptor(target, methodName);\n      // Method Decorator\n      const originalFn = descriptor.value || descriptor.originalFn;\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\nfunction createSelector(selectors, projector, creationMetadata) {\n  const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n  const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n  selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n  return memoizedFn;\n}\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor ||= Object.getOwnPropertyDescriptor(target, key);\n    const originalFn = descriptor?.value;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      if (originalFn && typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      },\n      originalFn\n    };\n    return newDescriptor;\n  };\n}\nclass NgxsDevelopmentModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsDevelopmentModule,\n      providers: [NgxsUnhandledActionsLogger, {\n        provide: NGXS_DEVELOPMENT_OPTIONS,\n        useValue: options\n      }]\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function NgxsDevelopmentModule_Factory(ɵt) {\n      return new (ɵt || NgxsDevelopmentModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxsDevelopmentModule\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsDevelopmentModule, [{\n    type: NgModule\n  }], null, null);\n})();\nfunction withNgxsDevelopmentOptions(options) {\n  return makeEnvironmentProviders([NgxsUnhandledActionsLogger, {\n    provide: NGXS_DEVELOPMENT_OPTIONS,\n    useValue: options\n  }]);\n}\nfunction ensureValidSelector(selector, context = {}) {\n  const noun = context.noun || 'selector';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  ensureValueProvided(selector, {\n    noun,\n    prefix: context.prefix\n  });\n  const metadata = _getSelectorMetadata(selector) || _getStoreMetadata(selector);\n  if (!metadata) {\n    throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n  }\n}\nfunction ensureValueProvided(value, context = {}) {\n  const noun = context.noun || 'value';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  if (!value) {\n    throw new Error(`${prefix}A ${noun} must be provided.`);\n  }\n}\nfunction createModelSelector(selectorMap) {\n  const selectorKeys = Object.keys(selectorMap);\n  const selectors = Object.values(selectorMap);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureValidSelectorMap({\n      prefix: '[createModelSelector]',\n      selectorMap,\n      selectorKeys,\n      selectors\n    });\n  }\n  return createSelector(selectors, (...args) => {\n    return selectorKeys.reduce((obj, key, index) => {\n      obj[key] = args[index];\n      return obj;\n    }, {});\n  });\n}\nfunction ensureValidSelectorMap({\n  prefix,\n  selectorMap,\n  selectorKeys,\n  selectors\n}) {\n  ensureValueProvided(selectorMap, {\n    prefix,\n    noun: 'selector map'\n  });\n  ensureValueProvided(typeof selectorMap === 'object', {\n    prefix,\n    noun: 'valid selector map'\n  });\n  ensureValueProvided(selectorKeys.length, {\n    prefix,\n    noun: 'non-empty selector map'\n  });\n  selectors.forEach((selector, index) => ensureValidSelector(selector, {\n    prefix,\n    noun: `selector for the '${selectorKeys[index]}' property`\n  }));\n}\nfunction createPickSelector(selector, keys) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureValidSelector(selector, {\n      prefix: '[createPickSelector]'\n    });\n  }\n  const validKeys = keys.filter(Boolean);\n  const selectors = validKeys.map(key => createSelector([selector], s => s[key]));\n  return createSelector([...selectors], (...props) => {\n    return validKeys.reduce((acc, key, index) => {\n      acc[key] = props[index];\n      return acc;\n    }, {});\n  });\n}\nfunction createPropertySelectors(parentSelector) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    ensureValidSelector(parentSelector, {\n      prefix: '[createPropertySelectors]',\n      noun: 'parent selector'\n    });\n  }\n  const cache = {};\n  return new Proxy({}, {\n    get(_target, prop) {\n      const selector = cache[prop] || createSelector([parentSelector], s => s?.[prop]);\n      cache[prop] = selector;\n      return selector;\n    }\n  });\n}\nfunction provideStore(states = [], ...optionsAndFeatures) {\n  const features = [];\n  // Options are empty by default (see `forRoot`).\n  let options = {};\n  if (optionsAndFeatures.length > 0) {\n    if (isEnvironmentProvider(optionsAndFeatures[0])) {\n      features.push(...optionsAndFeatures);\n    } else {\n      options = optionsAndFeatures[0];\n      features.push(...optionsAndFeatures.slice(1));\n    }\n  }\n  return makeEnvironmentProviders([...getRootProviders(states, options), NGXS_ROOT_ENVIRONMENT_INITIALIZER, features]);\n}\nfunction isEnvironmentProvider(target) {\n  return !!target.ɵproviders;\n}\n\n/**\n * This version serves as a standalone alternative to `NgxsModule.forFeature`.\n * It can be used in a similar manner to register feature states, but at the\n * `Route` providers level:\n *\n * ```ts\n * const routes: Routes = [\n *   {\n *     path: 'products',\n *     loadComponent: async () => {...},\n *     providers: [provideStates([ProductsState])]\n *   }\n * ];\n * ```\n */\nfunction provideStates(states, ...features) {\n  return makeEnvironmentProviders([...getFeatureProviders(states), features, NGXS_FEATURE_ENVIRONMENT_INITIALIZER]);\n}\n\n/**\n * This function registers a custom global plugin for the state.\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStore(\n *       [CountriesState],\n *       withNgxsPlugin(LogoutPlugin)\n *     )\n *   ]\n * });\n * ```\n */\nfunction withNgxsPlugin(plugin) {\n  return makeEnvironmentProviders([{\n    provide: NGXS_PLUGINS,\n    useClass: plugin,\n    multi: true\n  }]);\n}\n\n/**\n * This function serves as a utility and has multiple purposes.\n * Firstly, it allows you to select properties from the state class\n * without having to inject the store class and use `this.store.selectSignal`,\n * resulting in a more concise implementation. Secondly, it can be used with\n * other solutions such as NgRx signal store with its `signalStoreFeature` or\n * `withComputed` functionalities.\n *\n * Please note that it's named `select` instead of `selectSignal` because\n * signals are evolving into first-class primitives in Angular, displacing other\n * primitives such as observables. Observables represent a stream of events,\n * whereas signals represent a single value changing over time.\n */\nfunction select(selector) {\n  return inject(Store).selectSignal(selector);\n}\nfunction dispatch(ActionType) {\n  const store = inject(Store);\n  return (...args) => store.dispatch(new ActionType(...args));\n}\nfunction createSelectMap(selectorMap) {\n  const store = inject(Store);\n  return Object.entries(selectorMap).reduce((accumulator, [key, selector]) => {\n    Object.defineProperty(accumulator, key, {\n      enumerable: true,\n      value: store.selectSignal(selector)\n    });\n    return accumulator;\n  }, {});\n}\nfunction createDispatchMap(actionMap) {\n  return Object.entries(actionMap).reduce((accumulator, [key, ActionType]) => {\n    Object.defineProperty(accumulator, key, {\n      enumerable: true,\n      value: dispatch(ActionType)\n    });\n    return accumulator;\n  }, {});\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, NgxsConfig, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NgxsUnhandledErrorHandler, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, Store, createDispatchMap, createModelSelector, createPickSelector, createPropertySelectors, createSelectMap, createSelector, dispatch, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, provideStates, provideStore, select, withNgxsDevelopmentOptions, withNgxsPlugin, withNgxsPreboot, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };\n"],
  "mappings": "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",
  "names": ["value", "NG_DEV_MODE", "config", "propGetter", "NG_DEV_MODE$1", "NG_DEV_MODE"]
}
